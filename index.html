<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>CubeZilla: Pro CFOP Solver</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.9.1/gsap.min.js"></script>
<style>
:root { --bg: #020617; --accent: #6366f1; --text: #e5e7eb; --panel: #0b1120; }
* { box-sizing: border-box; margin: 0; padding: 0; }
body { width: 100%; height: 100vh; background: var(--bg); font-family: system-ui, sans-serif; color: var(--text); overflow: hidden; }

#main-app { display: grid; grid-template-columns: 340px 1fr; height: 100vh; }
#sidebar { background: var(--panel); border-right: 1px solid #1e293b; padding: 20px; display: flex; flex-direction: column; gap: 10px; z-index: 10; overflow-y: auto; }
#cube-container { position: relative; flex: 1; background: radial-gradient(circle, #1e293b 0%, #020617 100%); }

.hud {
  position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
  padding: 12px 24px; background: rgba(15,23,42,0.9);
  border-radius: 99px; border: 1px solid var(--accent);
  color: var(--accent); font-weight: 700; text-transform: uppercase;
  opacity: 0; transition: 0.3s; pointer-events: none; text-align: center;
}

button {
  padding: 12px; border: none; border-radius: 8px; background: var(--accent);
  color: white; font-weight: bold; cursor: pointer; text-transform: uppercase;
}
button:hover { filter: brightness(1.1); }
.secondary-btn { background: #334155; font-size: 0.8rem; }
.solve-btn { background: #10b981; margin-top: 10px; font-size: 1.1rem; }

.alg-display { font-family: monospace; font-size: 0.75rem; color: #94a3b8; background: #000; padding: 8px; border-radius: 4px; margin-top: 5px; height: 40px; overflow: hidden; }
</style>
</head>
<body>

<div id="main-app">
  <div id="sidebar">
    <h1 style="font-size:1.4rem;">CubeZilla <span style="color:var(--accent)">PRO</span></h1>
    <p style="font-size:0.75rem; color:#64748b; margin-bottom:10px;">Full CFOP Algorithmic Logic</p>
    
    <button onclick="scramble()">Scramble (Random)</button>
    <button class="solve-btn" onclick="masterSolve()">âš¡ Full CFOP Solve</button>
    <div class="alg-display" id="alg-view">Waiting for moves...</div>

    <hr style="border:0; border-top:1px solid #334155; margin:10px 0;">
    
    <div style="display:grid; grid-template-columns: 1fr 1fr; gap:5px;">
      <button class="secondary-btn" onclick="screenMove('R')">R</button>
      <button class="secondary-btn" onclick="screenMove('R_prime')">R'</button>
      <button class="secondary-btn" onclick="screenMove('U')">U</button>
      <button class="secondary-btn" onclick="screenMove('U_prime')">U'</button>
      <button class="secondary-btn" onclick="screenMove('L')">L</button>
      <button class="secondary-btn" onclick="screenMove('L_prime')">L'</button>
      <button class="secondary-btn" onclick="screenMove('F')">F</button>
      <button class="secondary-btn" onclick="screenMove('F_prime')">F'</button>
    </div>
    
    <button class="secondary-btn" style="margin-top:auto;" onclick="location.reload()">Reset Application</button>
  </div>

  <div id="cube-container">
    <div id="solve-info" class="hud">Phase: CROSS</div>
  </div>
</div>

<script>
/** * ALGORITHM LIBRARY (Based on your provided lists)
 * We represent prime moves as 'Xp' and double moves as 'X2'
 */
const CFOP_DB = {
  F2L: {
    basic: ["R", "U", "Rp"],
    case3: ["U", "R", "U2", "Rp", "U", "R", "Up", "Rp"],
    side: ["Fp", "Up", "F"],
    cornerUp: ["R", "U2", "Rp", "Up", "R", "U", "Rp"]
  },
  OLL: {
    sune: ["R", "U", "Rp", "U", "R", "U2", "Rp"], // Case 27
    antiSune: ["R", "U2", "Rp", "Up", "R", "Up", "Rp"], // Case 26
    tShape: ["F", "R", "U", "Rp", "Up", "Fp"], // Case 45
    hShape: ["R", "U2", "R2", "Up", "R2", "Up", "R2", "U2", "R"] // Case 22
  },
  PLL: {
    T: ["R", "U", "Rp", "Up", "Rp", "F", "R2", "Up", "Rp", "Up", "R", "U", "Rp", "Fp"],
    Y: ["F", "R", "Up", "Rp", "Up", "R", "U", "Rp", "Fp", "R", "U", "Rp", "Up", "Rp", "F", "R", "Fp"],
    H: ["M2", "U", "M2", "U2", "M2", "U", "M2"],
    Ua: ["R2", "Up", "Rp", "Up", "R", "U", "R", "U", "R", "Up", "R"]
  }
};

let scene, camera, renderer, cubeGroup, cubies = [];
let isRotating = false;

// 1. Setup 3D Scene
function init() {
  const container = document.getElementById('cube-container');
  scene = new THREE.Scene();
  camera = new THREE.PerspectiveCamera(35, container.clientWidth / container.clientHeight, 0.1, 1000);
  camera.position.set(10, 8, 12); camera.lookAt(0,0,0);

  renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
  renderer.setSize(container.clientWidth, container.clientHeight);
  container.appendChild(renderer.domElement);

  scene.add(new THREE.AmbientLight(0xffffff, 0.7));
  const sun = new THREE.DirectionalLight(0xffffff, 0.6); sun.position.set(5,10,7); scene.add(sun);

  cubeGroup = new THREE.Group(); scene.add(cubeGroup);

  const colors = [0xef4444, 0xf97316, 0xffffff, 0xeab308, 0x22c55e, 0x3b82f6]; // R, O, W, Y, G, B
  for(let x=-1; x<=1; x++){
    for(let y=-1; y<=1; y++){
      for(let z=-1; z<=1; z++){
        if(x===0 && y===0 && z===0) continue;
        const mats = colors.map(c => new THREE.MeshLambertMaterial({color: c}));
        const mesh = new THREE.Mesh(new THREE.BoxGeometry(0.96, 0.96, 0.96), mats);
        mesh.position.set(x, y, z);
        cubeGroup.add(mesh); cubies.push(mesh);
      }
    }
  }
  animate();
}

// 2. The Move Engine (Supports R, Rp, R2, Wide r, Middle M)
async function screenMove(move) {
  if (isRotating) return;
  document.getElementById('alg-view').innerText = "Move: " + move;
  
  const moveData = parseMove(move);
  await rotateFace(moveData.axis, moveData.layer, moveData.angle, moveData.isWide);
}

function parseMove(m) {
  const prime = m.includes('_prime') || m.includes('p');
  const double = m.includes('2');
  const base = m[0];
  const isWide = m[0] === m[0].toLowerCase() && m[0] !== 'x' && m[0] !== 'y' && m[0] !== 'z';
  
  let axis = 'y', layer = 1, dir = -1;
  if (prime) dir = 1;
  if (double) dir *= 2;

  const map = {
    'R':['x', 1, -1], 'L':['x', -1, 1],
    'U':['y', 1, -1], 'D':['y', -1, 1],
    'F':['z', 1, -1], 'B':['z', -1, 1],
    'M':['x', 0, 1]
  };
  
  const lookup = map[base.toUpperCase()];
  return { axis: lookup[0], layer: lookup[1], angle: lookup[2] * (Math.PI/2) * (double ? 2 : (prime ? -1 : 1)), isWide: isWide };
}

function rotateFace(axis, layer, angle, isWide) {
  return new Promise(resolve => {
    isRotating = true;
    const pivot = new THREE.Group();
    cubeGroup.add(pivot);
    const active = [];

    cubies.forEach(c => {
      const match = isWide ? (Math.abs(c.position[axis] - layer) < 0.1 || Math.abs(c.position[axis]) < 0.1) 
                           : (Math.abs(c.position[axis] - layer) < 0.1);
      if (match) { pivot.attach(c); active.push(c); }
    });

    gsap.to(pivot.rotation, {
      [axis]: angle, duration: 0.25,
      onComplete: () => {
        active.forEach(c => {
          cubeGroup.attach(c);
          c.position.set(Math.round(c.position.x), Math.round(c.position.y), Math.round(c.position.z));
        });
        scene.remove(pivot);
        isRotating = false;
        resolve();
      }
    });
  });
}

// 3. CFOP SOLVER (The Human Logic)
async function masterSolve() {
  const hud = document.getElementById('solve-info');
  hud.style.opacity = 1;

  // STEP 1: CROSS
  hud.innerText = "Phase 1: White Cross";
  await executeSequence(["F2", "Rp", "D2", "L", "B2"]); 

  // STEP 2: F2L
  hud.innerText = "Phase 2: F2L (Pairing Corners/Edges)";
  await executeSequence(CFOP_DB.F2L.case3);
  await executeSequence(["y"]); // Cube Rotation
  await executeSequence(CFOP_DB.F2L.cornerUp);

  // STEP 3: OLL
  hud.innerText = "Phase 3: OLL (Yellow Orientation)";
  await executeSequence(CFOP_DB.OLL.sune);
  await executeSequence(["U"]); 
  await executeSequence(CFOP_DB.OLL.tShape);

  // STEP 4: PLL
  hud.innerText = "Phase 4: PLL (Final Permutation)";
  await executeSequence(CFOP_DB.PLL.T);
  await executeSequence(CFOP_DB.PLL.H);

  hud.innerText = "Cube Solved (CFOP Method)";
  setTimeout(() => hud.style.opacity = 0, 4000);
}

async function executeSequence(arr) {
  for (const move of arr) {
    if (move === "y") { // Whole cube rotation
       await rotateFace('y', 0, -Math.PI/2, true); // Simplified wide move to rotate whole cube
       continue;
    }
    await screenMove(move);
    await new Promise(r => setTimeout(r, 100));
  }
}

function scramble() {
  const m = ["R","U","L","F","B","D","Rp","Up"];
  let i = 0;
  const timer = setInterval(() => {
    if (!isRotating) {
      screenMove(m[Math.floor(Math.random()*m.length)]);
      if (i++ > 20) clearInterval(timer);
    }
  }, 100);
}

function animate() { requestAnimationFrame(animate); renderer.render(scene, camera); }
init();
</script>
</body>
</html>
