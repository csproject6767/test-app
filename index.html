<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>CubeZilla Solver</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.9.1/gsap.min.js"></script>
<style>
:root {
  --bg-main: #020617;
  --bg-panel: #0b1120;
  --bg-glass: rgba(15, 23, 42, 0.92);
  --accent-primary: #6366f1;
  --accent-glow: #8b5cf6;
  --accent-soft: #a5b4fc;
  --text-main: #e5e7eb;
  --text-muted: #9ca3af;
  --border-glow: rgba(99, 102, 241, 0.4);
}

* { box-sizing: border-box; margin: 0; padding: 0; }

body {
  width: 100%;
  height: 100vh;
  background:
    radial-gradient(ellipse at top left, rgba(99,102,241,0.18) 0%, transparent 55%),
    radial-gradient(ellipse at bottom right, rgba(139,92,246,0.16) 0%, transparent 55%),
    linear-gradient(135deg, #020617 0%, #020617 100%);
  font-family: -apple-system, BlinkMacSystemFont, system-ui, sans-serif;
  color: var(--text-main);
  overflow: hidden;
}

/* Start overlay */
#overlay {
  position: fixed;
  inset: 0;
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 100;
  background: radial-gradient(circle at 10% 10%, rgba(79,70,229,0.35) 0%, transparent 45%),
              radial-gradient(circle at 90% 90%, rgba(147,51,234,0.3) 0%, transparent 45%),
              rgba(2,6,23,0.96);
}

.page {
  text-align: left;
  padding: 40px 44px 32px;
  max-width: 480px;
  width: 90vw;
  background: linear-gradient(145deg, rgba(15,23,42,0.96) 0%, rgba(15,23,42,0.92) 100%);
  border-radius: 26px;
  border: 1px solid rgba(148,163,184,0.4);
  box-shadow: 0 30px 80px rgba(15,23,42,0.9), 0 0 40px rgba(79,70,229,0.4);
  position: relative;
  overflow: hidden;
}

.page h1 {
  font-size: 2.1rem;
  margin-bottom: 12px;
  letter-spacing: -0.03em;
  background: linear-gradient(135deg, #e5e7eb, #a5b4fc);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
}

.page p {
  margin-bottom: 18px;
  color: var(--text-muted);
  line-height: 1.6;
  font-size: 0.95rem;
}

/* Buttons */
.pop-btn, button {
  padding: 12px 26px;
  background: linear-gradient(135deg, var(--accent-primary), var(--accent-glow));
  color: white;
  border: none;
  border-radius: 999px;
  cursor: pointer;
  font-weight: 600;
  font-size: 0.95rem;
  letter-spacing: 0.05em;
  text-transform: uppercase;
  position: relative;
  overflow: hidden;
  transition: transform 0.2s ease, box-shadow 0.2s ease;
  box-shadow: 0 18px 40px rgba(59,130,246,0.45);
}

.pop-btn:hover, button:hover {
  transform: translateY(-2px) scale(1.02);
  box-shadow: 0 24px 55px rgba(79,70,229,0.6);
}

/* App Layout */
#main-app {
  display: none;
  height: 100vh;
  grid-template-columns: 300px 1fr;
}

#sidebar {
  background: #020617;
  border-right: 1px solid rgba(15,23,42,1);
  padding: 22px 20px;
  display: flex;
  flex-direction: column;
  gap: 16px;
  box-shadow: 10px 0 40px rgba(0,0,0,0.6);
}

#method-title {
  font-size: 0.9rem;
  color: var(--accent-soft);
  letter-spacing: 0.16em;
  text-transform: uppercase;
  margin-bottom: 8px;
}

#cube-container {
  position: relative;
  flex: 1;
}

/* HUD elements */
#solve-info {
  position: absolute;
  top: 20px;
  left: 50%;
  transform: translateX(-50%);
  padding: 8px 18px;
  background: rgba(15,23,42,0.95);
  border-radius: 999px;
  border: 1px solid rgba(148,163,184,0.6);
  color: var(--text-muted);
  font-size: 0.8rem;
  text-transform: uppercase;
  opacity: 0;
  transition: opacity 0.3s ease;
  z-index: 10;
}

.camera-column {
  position: absolute;
  top: 50%;
  left: 24px;
  transform: translateY(-50%);
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.camera-btn {
  width: 46px; height: 46px;
  background: #111827; color: #e5e7eb;
  border-radius: 14px; border: 1px solid #374151;
  cursor: pointer; font-weight: 600;
}

.move-bar {
  position: absolute;
  bottom: 34px;
  left: 50%;
  transform: translateX(-50%);
  display: flex;
  gap: 10px;
  padding: 14px 16px;
  background: rgba(15,23,42,0.98);
  border-radius: 18px;
  border: 1px solid #334155;
}

.move-btn {
  padding: 8px 10px;
  min-width: 40px;
  background: #0f172a;
  color: #e5e7eb;
  border-radius: 10px;
  border: 1px solid #374151;
  cursor: pointer;
}
</style>
</head>
<body>

<div id="overlay">
  <div class="page">
    <h1>CubeZilla Solver</h1>
    <p>A cinematic 3D Rubik’s cube that records every move you make and can rewind the entire scramble on command.</p>
    <p style="margin-bottom: 22px;">
      Learn how a solver “thinks” through CFOP-style phases while you experiment with your own scrambles.
    </p>

    <div style="display:flex; flex-direction:column; gap:12px; margin-bottom:26px;">
      <button class="pop-btn" onclick="startSolver()">▶ Solve a scramble</button>

      <button class="pop-btn" 
              style="background:linear-gradient(135deg,#0f172a,#111827); box-shadow:none; border:1px solid rgba(148,163,184,0.5); color:#e5e7eb;"
              onclick="openHowItWorks()">
        ? How does the app work?
      </button>

      <button class="pop-btn" style="background:linear-gradient(135deg,#22c55e,#16a34a); box-shadow:0 18px 40px rgba(34,197,94,0.4);"
              onclick="startSolver()">
        ⚡ Free‑play with the cube
      </button>
    </div>

    <div style="margin-top:10px; padding-top:10px; border-top:1px solid rgba(55,65,81,0.7); display:flex; justify-content:space-between; align-items:center; font-size:0.8rem; color:#9ca3af;">
      <span>Credits: Anirudh · Madhav · Pratik</span>
      <span style="opacity:0.8;">v1.0 · experimental</span>
    </div>
  </div>
</div>

<div id="main-app">
  <div id="sidebar">
    <h2 id="method-title">CONTROLS</h2>
    <button class="pop-btn" onclick="scramble()">Scramble</button>
    <button class="pop-btn" onclick="solveCube()">Solve</button>
    <button class="pop-btn" onclick="resetCube()">Reset Cube</button>
    <button class="pop-btn" onclick="resetView()">Reset View</button>
    <button class="pop-btn" style="background:#374151" onclick="backToMenu()">Back to menu</button>
  </div>
  <div id="cube-container">
    <div id="solve-info"></div>
    <div class="camera-column">
      <button class="camera-btn" onclick="snapAndReorient('front')">F</button>
      <button class="camera-btn" onclick="snapAndReorient('right')">R</button>
      <button class="camera-btn" onclick="snapAndReorient('back')">B</button>
      <button class="camera-btn" onclick="snapAndReorient('left')">L</button>
      <button class="camera-btn" onclick="snapAndReorient('up')">U</button>
      <button class="camera-btn" onclick="snapAndReorient('down')">D</button>
    </div>
    <div class="move-bar">
      <button class="move-btn" onclick="screenMove('R')">R</button>
      <button class="move-btn" onclick="screenMove('R_prime')">R'</button>
      <button class="move-btn" onclick="screenMove('L')">L</button>
      <button class="move-btn" onclick="screenMove('L_prime')">L'</button>
      <button class="move-btn" onclick="screenMove('U')">U</button>
      <button class="move-btn" onclick="screenMove('U_prime')">U'</button>
      <button class="move-btn" onclick="screenMove('F')">F</button>
      <button class="move-btn" onclick="screenMove('F_prime')">F'</button>
    </div>
  </div>
</div>

<script>
let scene, camera, renderer, cubies = [], cubeGroup;
let moveHistory = [];
let isRotating = false, isChangingView = false;
let currentView = { theta: 0, phi: 0.3 };
const zoomDistance = 12;

const solveMessages = {
  scan: ['Scanning piece positions', 'Reading current cube pattern', 'Profiling piece cycles'],
  eval: ['Comparing CFOP efficiencies', 'Scoring first-layer options'],
  method: ['Found fastest method: CFOP hybrid'],
  execute: ['Executing: Cross → F2L → OLL → PLL']
};

function pickRandom(list) { return list[Math.floor(Math.random() * list.length)]; }

function setSolveInfo(text) {
  const el = document.getElementById('solve-info');
  if (!el) return;
  el.textContent = text;
  el.style.opacity = text ? '1' : '0';
}

function openHowItWorks() {
  const win = window.open('', '_blank');
  if (!win) return;
  win.document.write(`
    <!DOCTYPE html>
    <html>
    <head>
      <title>How CubeZilla Works</title>
      <meta charset="UTF-8" />
      <style>
        body { margin: 0; padding: 32px 24px; font-family: -apple-system, sans-serif; background: #020617; color: #e5e7eb; }
        .card { max-width: 720px; margin: 0 auto; background: #0b1120; border-radius: 24px; border: 1px solid rgba(148,163,184,0.4); padding: 28px; box-shadow: 0 30px 80px rgba(0,0,0,0.5); }
        h1 { font-size: 1.6rem; margin-bottom: 10px; }
        p { font-size: 0.95rem; color: #9ca3af; line-height: 1.6; }
        ul { margin: 15px 0 0 20px; color: #d1d5db; }
        li { margin-bottom: 8px; }
      </style>
    </head>
    <body>
      <div class="card">
        <h1>How CubeZilla Works</h1>
        <p>CubeZilla is a 3D Rubik's cube playground. It tracks every move you make and can rewind the entire scramble with CFOP‑style commentary.</p>
        <ul>
          <li><strong>Scramble</strong>: Click “Scramble” or spam the move buttons to create your own scramble.</li>
          <li><strong>Track</strong>: Every move you do is stored in order.</li>
          <li><strong>View</strong>: Use the F/R/B/L/U/D buttons to change perspective.</li>
          <li><strong>Solve</strong>: Rewinds history while showing random CFOP‑style messages.</li>
          <li><strong>Reset</strong>: Returns everything to a fresh solved state.</li>
        </ul>
      </div>
    </body>
    </html>
  `);
  win.document.close();
}

function backToMenu() { location.reload(); }

function startSolver() {
  document.getElementById('overlay').style.display = 'none';
  document.getElementById('main-app').style.display = 'grid';
  setup3D();
}

function setup3D() {
  const container = document.getElementById('cube-container');
  scene = new THREE.Scene();
  camera = new THREE.PerspectiveCamera(35, container.clientWidth / container.clientHeight, 0.1, 1000);
  renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
  renderer.setSize(container.clientWidth, container.clientHeight);
  container.appendChild(renderer.domElement);

  scene.add(new THREE.AmbientLight(0xffffff, 0.7));
  const dl = new THREE.DirectionalLight(0xffffff, 0.8);
  dl.position.set(3, 5, 4);
  scene.add(dl);

  cubeGroup = new THREE.Group();
  scene.add(cubeGroup);

  const colors = [0xff0000, 0xffa500, 0xffffff, 0xffff00, 0x00ff00, 0x0000ff];
  for (let x = -1; x <= 1; x++) {
    for (let y = -1; y <= 1; y++) {
      for (let z = -1; z <= 1; z++) {
        if (x === 0 && y === 0 && z === 0) continue;
        const mats = colors.map(c => new THREE.MeshLambertMaterial({ color: c }));
        const cubie = new THREE.Mesh(new THREE.BoxGeometry(0.95, 0.95, 0.95), mats);
        cubie.position.set(x, y, z);
        cubies.push(cubie);
        cubeGroup.add(cubie);
      }
    }
  }

  snapAndReorient('front');
  animate();
}

function snapAndReorient(face) {
  if (isRotating || isChangingView) return;
  const va = {
    front: { t: 0, p: 0.3 },
    right: { t: -Math.PI/2, p: 0.3 },
    back: { t: Math.PI, p: 0.3 },
    left: { t: Math.PI/2, p: 0.3 },
    up: { t: 0, p: -Math.PI/2 + 0.2 },
    down: { t: 0, p: Math.PI/2 - 0.2 }
  };
  const target = va[face];
  isChangingView = true;
  gsap.to(currentView, {
    theta: target.t, phi: target.p, duration: 0.6,
    onUpdate: () => {
      camera.position.set(
        zoomDistance * Math.cos(currentView.phi) * Math.sin(currentView.theta),
        zoomDistance * Math.sin(currentView.phi),
        zoomDistance * Math.cos(currentView.phi) * Math.cos(currentView.theta)
      );
      camera.lookAt(0, 0, 0);
    },
    onComplete: () => { isChangingView = false; }
  });
}

function screenMove(move) {
  let prime = move.endsWith('_prime');
  let cleanMove = move.replace('_prime', '');
  const dirs = { R:[1,0,0], L:[-1,0,0], U:[0,1,0], D:[0,-1,0], F:[0,0,1], B:[0,0,-1] };
  
  let worldDir = new THREE.Vector3(...dirs[cleanMove]);
  const inv = cubeGroup.quaternion.clone().invert();
  worldDir.applyQuaternion(inv);

  let axisName, layerSign;
  const ax = Math.abs(worldDir.x), ay = Math.abs(worldDir.y), az = Math.abs(worldDir.z);
  if (ax > ay && ax > az) { axisName = 'x'; layerSign = worldDir.x > 0 ? 1 : -1; }
  else if (ay > ax && ay > az) { axisName = 'y'; layerSign = worldDir.y > 0 ? 1 : -1; }
  else { axisName = 'z'; layerSign = worldDir.z > 0 ? 1 : -1; }

  moveHistory.push(move);
  handleMove(axisName, layerSign, prime);
}

function handleMove(axis, layerSign, prime) {
  if (isRotating) return;
  isRotating = true;
  const pivot = new THREE.Group();
  cubeGroup.add(pivot);
  const moving = [];
  cubies.forEach(c => {
    if (Math.abs(c.position[axis] - layerSign) < 0.1) {
      pivot.attach(c);
      moving.push(c);
    }
  });
  
  gsap.to(pivot.rotation, {
    [axis]: (prime ? 1 : -1) * Math.PI / 2, duration: 0.25,
    onComplete: () => {
      moving.forEach(c => {
        cubeGroup.attach(c);
        c.position.set(Math.round(c.position.x), Math.round(c.position.y), Math.round(c.position.z));
      });
      scene.remove(pivot);
      isRotating = false;
    }
  });
}

function scramble() {
  let count = 0;
  const moves = ['R','R_prime','L','L_prime','U','U_prime','F','F_prime'];
  const interval = setInterval(() => {
    if (isRotating || isChangingView) return;
    if (count >= 15) { clearInterval(interval); return; }
    screenMove(moves[Math.floor(Math.random() * moves.length)]);
    count++;
  }, 280);
}

function solveCube() {
  if (moveHistory.length === 0) return;
  const rev = moveHistory.slice().reverse().map(m => m.endsWith('_prime') ? m.replace('_prime','') : m + '_prime');
  
  setSolveInfo(pickRandom(solveMessages.scan));
  setTimeout(() => {
    setSolveInfo(pickRandom(solveMessages.eval));
    setTimeout(() => {
      setSolveInfo(pickRandom(solveMessages.execute));
      let idx = 0;
      const interval = setInterval(() => {
        if (isRotating || isChangingView) return;
        if (idx >= rev.length) {
          clearInterval(interval);
          moveHistory = [];
          setSolveInfo('Solved!');
          setTimeout(() => setSolveInfo(''), 2000);
          return;
        }
        screenMove(rev[idx++]);
      }, 350);
    }, 1000);
  }, 1000);
}

function resetCube() { location.reload(); }
function resetView() { snapAndReorient('front'); }
function animate() { requestAnimationFrame(animate); renderer.render(scene, camera); }
</script>
</body>
</html>
