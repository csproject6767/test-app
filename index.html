<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Rubik's Cube Trainer</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r152/three.min.js"></script>
<style>
html, body {
  margin: 0;
  width: 100%;
  height: 100%;
  background: #000;
  overflow: hidden;
  font-family: monospace;
}
#ui {
  position: fixed;
  left: 10px;
  top: 10px;
  color: #0f0;
  z-index: 10;
}
button {
  background: black;
  border: 1px solid #0f0;
  color: #0f0;
  padding: 8px 14px;
  margin-top: 6px;
  cursor: pointer;
}
button:hover {
  background: #0f0;
  color: black;
}
</style>
</head>
<body>

<div id="ui">
  <h3>Rubik Trainer</h3>
  <button onclick="scramble()">Scramble</button>
  <button onclick="resetCube()">Reset</button>
</div>

<script>
/* -------------------- SCENE -------------------- */
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(45, innerWidth / innerHeight, 0.1, 100);
camera.position.set(6, 6, 6);
camera.lookAt(0, 0, 0);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(innerWidth, innerHeight);
document.body.appendChild(renderer.domElement);

window.addEventListener('resize', () => {
  camera.aspect = innerWidth / innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});

scene.add(new THREE.AmbientLight(0xffffff, 0.8));
const light = new THREE.DirectionalLight(0xffffff, 0.5);
light.position.set(5, 10, 7);
scene.add(light);

/* -------------------- CUBE DATA -------------------- */
const cubeGroup = new THREE.Group();
scene.add(cubeGroup);

const cubies = [];
const size = 1;
const gap = 0.05;

const COLORS = {
  R: 0xff0000,
  L: 0xff8000,
  U: 0xffffff,
  D: 0xffff00,
  F: 0x00ff00,
  B: 0x0000ff,
  X: 0x000000
};

function createCubie(x, y, z) {
  const materials = [
    new THREE.MeshLambertMaterial({ color: x ===  1 ? COLORS.R : COLORS.X }),
    new THREE.MeshLambertMaterial({ color: x === -1 ? COLORS.L : COLORS.X }),
    new THREE.MeshLambertMaterial({ color: y ===  1 ? COLORS.U : COLORS.X }),
    new THREE.MeshLambertMaterial({ color: y === -1 ? COLORS.D : COLORS.X }),
    new THREE.MeshLambertMaterial({ color: z ===  1 ? COLORS.F : COLORS.X }),
    new THREE.MeshLambertMaterial({ color: z === -1 ? COLORS.B : COLORS.X }),
  ];

  const mesh = new THREE.Mesh(
    new THREE.BoxGeometry(size, size, size),
    materials
  );

  mesh.position.set(x, y, z);
  mesh.userData.coord = new THREE.Vector3(x, y, z);

  cubeGroup.add(mesh);
  cubies.push(mesh);
}

function buildCube() {
  cubies.length = 0;
  cubeGroup.clear();
  for (let x = -1; x <= 1; x++)
    for (let y = -1; y <= 1; y++)
      for (let z = -1; z <= 1; z++)
        createCubie(x * (size + gap), y * (size + gap), z * (size + gap));
}
buildCube();

/* -------------------- CONTROLS -------------------- */
let isRotating = false;
const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();

let dragStart = null;
let pickedFace = null;
let pickedCubie = null;

/* CAMERA ROTATION */
let camRot = { x: 0, y: 0 };

renderer.domElement.addEventListener('pointerdown', e => {
  dragStart = { x: e.clientX, y: e.clientY };

  mouse.x = (e.clientX / innerWidth) * 2 - 1;
  mouse.y = -(e.clientY / innerHeight) * 2 + 1;
  raycaster.setFromCamera(mouse, camera);

  const hits = raycaster.intersectObjects(cubies);
  if (hits.length) {
    pickedCubie = hits[0].object;
    pickedFace = hits[0].face.normal.clone();
  } else {
    pickedCubie = null;
  }
});

renderer.domElement.addEventListener('pointerup', e => {
  if (!dragStart) return;

  const dx = e.clientX - dragStart.x;
  const dy = e.clientY - dragStart.y;

  if (!pickedCubie) {
    camRot.y += dx * 0.005;
    camRot.x += dy * 0.005;
    cubeGroup.rotation.set(camRot.x, camRot.y, 0);
  } else {
    if (!isRotating) performFaceTurn(pickedCubie, pickedFace, dx, dy);
  }

  dragStart = null;
  pickedCubie = null;
});

/* -------------------- FACE ROTATION -------------------- */
function performFaceTurn(cubie, normal, dx, dy) {
  isRotating = true;

  let axis, layer, dir;
  const threshold = Math.abs(dx) > Math.abs(dy) ? dx : dy;

  if (Math.abs(normal.x) === 1) {
    axis = 'x';
    layer = cubie.position.x;
    dir = threshold > 0 ? 1 : -1;
  } else if (Math.abs(normal.y) === 1) {
    axis = 'y';
    layer = cubie.position.y;
    dir = threshold > 0 ? 1 : -1;
  } else {
    axis = 'z';
    layer = cubie.position.z;
    dir = threshold > 0 ? 1 : -1;
  }

  rotateLayer(axis, layer, dir);
}

function rotateLayer(axis, layer, dir) {
  const pivot = new THREE.Group();
  scene.add(pivot);

  const moving = cubies.filter(c =>
    Math.abs(c.position[axis] - layer) < 0.1
  );

  moving.forEach(c => pivot.attach(c));

  const target = {};
  target[axis] = dir * Math.PI / 2;

  new THREE.Clock();
  const start = performance.now();

  function animateTurn() {
    const t = Math.min((performance.now() - start) / 200, 1);
    pivot.rotation[axis] = target[axis] * t;

    if (t < 1) requestAnimationFrame(animateTurn);
    else {
      moving.forEach(c => {
        cubeGroup.attach(c);
        c.position.x = Math.round(c.position.x);
        c.position.y = Math.round(c.position.y);
        c.position.z = Math.round(c.position.z);
        c.rotation.set(
          Math.round(c.rotation.x / (Math.PI/2)) * (Math.PI/2),
          Math.round(c.rotation.y / (Math.PI/2)) * (Math.PI/2),
          Math.round(c.rotation.z / (Math.PI/2)) * (Math.PI/2)
        );
      });
      scene.remove(pivot);
      isRotating = false;
    }
  }
  animateTurn();
}

/* -------------------- ACTIONS -------------------- */
function scramble() {
  if (isRotating) return;
  const axes = ['x','y','z'];
  let i = 0;
  const s = setInterval(() => {
    rotateLayer(
      axes[Math.floor(Math.random()*3)],
      [-1,0,1][Math.floor(Math.random()*3)] * (size+gap),
      Math.random() > 0.5 ? 1 : -1
    );
    if (++i > 12) clearInterval(s);
  }, 250);
}

function resetCube() {
  buildCube();
}

/* -------------------- LOOP -------------------- */
function animate() {
  requestAnimationFrame(animate);
  renderer.render(scene, camera);
}
animate();
</script>
</body>
</html>
