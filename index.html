<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>CubeZilla Solver</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.9.1/gsap.min.js"></script>
<style>
:root {
  --bg-main: #020617;
  --bg-panel: #0b1120;
  --bg-glass: rgba(15, 23, 42, 0.92);
  --accent-primary: #6366f1;
  --accent-glow: #8b5cf6;
  --accent-soft: #a5b4fc;
  --text-main: #e5e7eb;
  --text-muted: #9ca3af;
  --border-glow: rgba(99, 102, 241, 0.4);
}

* { box-sizing: border-box; margin: 0; padding: 0; }

body {
  width: 100%;
  height: 100vh;
  background:
    radial-gradient(ellipse at top left, rgba(99,102,241,0.18) 0%, transparent 55%),
    radial-gradient(ellipse at bottom right, rgba(139,92,246,0.16) 0%, transparent 55%),
    linear-gradient(135deg, #020617 0%, #020617 100%);
  font-family: -apple-system, BlinkMacSystemFont, system-ui, sans-serif;
  color: var(--text-main);
  overflow: hidden;
}

#overlay {
  position: fixed;
  inset: 0;
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 100;
  background: radial-gradient(circle at 10% 10%, rgba(79,70,229,0.35) 0%, transparent 45%),
              radial-gradient(circle at 90% 90%, rgba(147,51,234,0.3) 0%, transparent 45%),
              rgba(2,6,23,0.96);
}

.page {
  text-align: left;
  padding: 40px 44px 32px;
  max-width: 480px;
  width: 90vw;
  background: linear-gradient(145deg, rgba(15,23,42,0.96) 0%, rgba(15,23,42,0.92) 100%);
  border-radius: 26px;
  border: 1px solid rgba(148,163,184,0.4);
  box-shadow: 0 30px 80px rgba(15,23,42,0.9), 0 0 40px rgba(79,70,229,0.4);
  position: relative;
  overflow: hidden;
}

.page h1 {
  font-size: 2.1rem;
  margin-bottom: 12px;
  letter-spacing: -0.03em;
  background: linear-gradient(135deg, #e5e7eb, #a5b4fc);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
}

.page p {
  margin-bottom: 18px;
  color: var(--text-muted);
  line-height: 1.6;
  font-size: 0.95rem;
}

.pop-btn, button {
  padding: 12px 26px;
  background: linear-gradient(135deg, var(--accent-primary), var(--accent-glow));
  color: white;
  border: none;
  border-radius: 999px;
  cursor: pointer;
  font-weight: 600;
  font-size: 0.95rem;
  letter-spacing: 0.05em;
  text-transform: uppercase;
  transition: transform 0.2s ease, box-shadow 0.2s ease;
  box-shadow: 0 18px 40px rgba(59,130,246,0.45), 0 0 0 1px rgba(129,140,248,0.6);
}

.pop-btn:hover, button:hover {
  transform: translateY(-2px) scale(1.02);
  box-shadow: 0 24px 55px rgba(79,70,229,0.6), 0 0 0 1px rgba(191,219,254,0.9);
}

#main-app { display: none; height: 100vh; grid-template-columns: 300px 1fr; }

#sidebar {
  background: linear-gradient(180deg, #020617 0%, #020617 60%, #020617 100%);
  border-right: 1px solid rgba(15,23,42,1);
  padding: 22px 20px;
  display: flex;
  flex-direction: column;
  gap: 16px;
  box-shadow: 10px 0 40px rgba(0,0,0,0.6);
}

#method-title {
  font-size: 0.9rem;
  color: var(--accent-soft);
  letter-spacing: 0.16em;
  text-transform: uppercase;
  margin-bottom: 8px;
}

#cube-container { position: relative; flex: 1; }

#solve-info {
  position: absolute;
  top: 20px;
  left: 50%;
  transform: translateX(-50%);
  padding: 8px 18px;
  background: rgba(15,23,42,0.95);
  border-radius: 999px;
  border: 1px solid rgba(148,163,184,0.6);
  color: var(--text-muted);
  font-size: 0.8rem;
  letter-spacing: 0.08em;
  text-transform: uppercase;
  opacity: 0;
  transition: opacity 0.3s ease;
  z-index: 10;
}

.camera-column {
  position: absolute;
  top: 50%;
  left: 24px;
  transform: translateY(-50%);
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.camera-btn {
  width: 46px; height: 46px;
  background: radial-gradient(circle at 30% 0%, #111827, #020617);
  color: #e5e7eb; border-radius: 14px;
  border: 1px solid rgba(75,85,99,0.9); cursor: pointer;
}

.move-bar {
  position: absolute;
  bottom: 34px; left: 50%;
  transform: translateX(-50%);
  display: flex; gap: 10px;
  padding: 14px 16px;
  background: rgba(15,23,42,0.98);
  border-radius: 18px; border: 1px solid rgba(51,65,85,0.9);
}

.move-btn {
  padding: 8px 10px; min-width: 40px;
  background: #0f172a; color: #e5e7eb;
  border-radius: 10px; border: 1px solid rgba(55,65,81,0.9);
  cursor: pointer; font-size: 0.8rem; text-transform: uppercase;
}

/* --- Net Editor CSS --- */
.face-net {
  width: 70px; height: 70px;
  display: grid; grid-template-columns: repeat(3, 1fr);
  grid-template-rows: repeat(3, 1fr); gap: 2px;
}
.facelet {
  width: 100%; height: 100%; border-radius: 3px;
  background: #020617; border: 1px solid #1f2937; cursor: pointer;
}
.facelet.center { cursor: default; }
.palette-color {
  width: 26px; height: 26px; border-radius: 999px;
  border: 2px solid transparent; cursor: pointer;
}
.palette-color.selected {
  border-color: #f9fafb;
  box-shadow: 0 0 0 2px rgba(59,130,246,0.7);
}
</style>
</head>
<body>

<div id="overlay">
  <div class="page">
    <h1>CubeZilla Solver</h1>
    <p>A cinematic 3D Rubik‚Äôs cube that records every move you make and can rewind the entire scramble on command.</p>
    <div style="display:flex; flex-direction:column; gap:12px; margin-bottom:26px;">
      <button class="pop-btn" onclick="startSolver()">‚ñ∂ Solve a scramble</button>
      <button class="pop-btn" style="background:linear-gradient(135deg,#0f172a,#111827); box-shadow:none; border:1px solid rgba(148,163,184,0.5); color:#e5e7eb;"
              onclick="openHowItWorks()">? How does the app work?</button>
      <button class="pop-btn" style="background:linear-gradient(135deg,#22c55e,#16a34a); box-shadow:0 18px 40px rgba(34,197,94,0.4);"
              onclick="startNetInput()">üé® Solve from colors</button>
    </div>
    <div style="margin-top:10px; padding-top:10px; border-top:1px solid rgba(55,65,81,0.7); display:flex; justify-content:space-between; align-items:center; font-size:0.8rem; color:#9ca3af;">
      <span>Credits: Anirudh ¬∑ Madhav ¬∑ Pratik</span>
      <span style="opacity:0.8;">v1.0</span>
    </div>
  </div>
</div>

<div id="main-app">
  <div id="sidebar">
    <h2 id="method-title">CONTROLS</h2>
    <button class="pop-btn" onclick="scramble()">Scramble</button>
    <button class="pop-btn" onclick="solveCube()">Solve</button>
    <button class="pop-btn" onclick="resetCube()">Reset Cube</button>
    <button class="pop-btn" onclick="resetView()">Reset View</button>
    <button class="pop-btn" style="background:#374151" onclick="backToMenu()">Back to menu</button>
  </div>
  <div id="cube-container">
    <div id="net-editor" style="position:absolute; inset:0; display:none; align-items:center; justify-content:center; background:rgba(2,6,23,0.98); z-index:20;">
      <div style="background:#020617; border-radius:24px; padding:20px 22px 18px; border:1px solid rgba(148,163,184,0.4); max-width:900px; width:95vw; color:#e5e7eb;">
        <h2 style="font-size:1rem; letter-spacing:0.16em; text-transform:uppercase; margin-bottom:8px; color:#a5b4fc;">Solve from colors</h2>
        <p style="font-size:0.9rem; color:#9ca3af; margin-bottom:14px;">Click stickers to paint. Centers are fixed. Press Done to build.</p>
        <div id="net-faces" style="display:grid; grid-template-columns:repeat(4,70px); grid-gap:10px; justify-content:center; margin-bottom:16px;">
          <div></div><div id="face-U" class="face-net"></div><div></div><div></div>
          <div id="face-L" class="face-net"></div><div id="face-F" class="face-net"></div><div id="face-R" class="face-net"></div><div id="face-B" class="face-net"></div>
          <div></div><div id="face-D" class="face-net"></div><div></div><div></div>
        </div>
        <div id="palette" style="display:flex; gap:8px; justify-content:center; margin-bottom:14px;"></div>
        <div style="display:flex; justify-content:space-between; align-items:center;">
          <button class="pop-btn" style="padding:8px 16px; font-size:0.8rem;" onclick="cancelNetInput()">Cancel</button>
          <div style="display:flex; gap:8px;">
            <button class="pop-btn" style="padding:8px 16px; font-size:0.8rem; background:#0f172a;" onclick="clearNetColors()">Clear</button>
            <button class="pop-btn" style="padding:8px 16px; font-size:0.8rem;" onclick="applyNetToCube()">Done</button>
          </div>
        </div>
      </div>
    </div>
    <div id="solve-info"></div>
    <div class="camera-column">
      <button class="camera-btn" onclick="snapAndReorient('front')">F</button>
      <button class="camera-btn" onclick="snapAndReorient('right')">R</button>
      <button class="camera-btn" onclick="snapAndReorient('back')">B</button>
      <button class="camera-btn" onclick="snapAndReorient('left')">L</button>
      <button class="camera-btn" onclick="snapAndReorient('up')">U</button>
      <button class="camera-btn" onclick="snapAndReorient('down')">D</button>
    </div>
    <div class="move-bar">
      <button class="move-btn" onclick="screenMove('R')">R</button>
      <button class="move-btn" onclick="screenMove('R_prime')">R'</button>
      <button class="move-btn" onclick="screenMove('L')">L</button>
      <button class="move-btn" onclick="screenMove('L_prime')">L'</button>
      <button class="move-btn" onclick="screenMove('U')">U</button>
      <button class="move-btn" onclick="screenMove('U_prime')">U'</button>
      <button class="move-btn" onclick="screenMove('F')">F</button>
      <button class="move-btn" onclick="screenMove('F_prime')">F'</button>
    </div>
  </div>
</div>

<script>
let scene, camera, renderer, cubies = [], cubeGroup;
let moveHistory = [];
let isRotating = false, isChangingView = false;
let currentView = { theta: 0, phi: 0.3 };
const zoomDistance = 12;

// --- Net State ---
const NET_COLORS = { U: '#ffff00', D: '#ffffff', F: '#00ff00', B: '#0000ff', R: '#ff0000', L: '#ff8000' };
const NET_PALETTE = Object.values(NET_COLORS);
let selectedNetColor = NET_PALETTE[0];
let netFacelets = {};
let customFaceColors = null;

const solveMessages = {
  scan: ['Scanning cross & F2L pairs', 'Reading current cube pattern'],
  eval: ['Comparing CFOP vs beginner routes', 'Checking white cross efficiencies'],
  method: ['Found fastest method: CFOP-style route', 'Using: Optimized F2L + 2-Look OLL'],
  execute: ['Executing: Cross ‚Üí F2L ‚Üí OLL ‚Üí PLL', 'Orient last layer, then permute']
};

function pickRandom(list) { return list[Math.floor(Math.random() * list.length)]; }
function setSolveInfo(text) {
  const el = document.getElementById('solve-info');
  if (el) { el.textContent = text; el.style.opacity = text ? '1' : '0'; }
}

// 1) New Page Function
function openHowItWorks() {
  const win = window.open('', '_blank');
  if (!win) return;
  win.document.write(`
    <!DOCTYPE html>
    <html>
    <head>
      <meta charset="UTF-8" />
      <title>How CubeZilla Works</title>
      <style>
        body { margin: 0; padding: 32px 24px 40px; font-family: -apple-system, system-ui, sans-serif; background: #020617; color: #e5e7eb; }
        .card { max-width: 720px; margin: 0 auto; background: #0b1120; border-radius: 24px; border: 1px solid rgba(148,163,184,0.4); padding: 28px; box-shadow: 0 30px 80px rgba(15,23,42,0.9); }
        h1 { font-size: 1.6rem; margin-bottom: 10px; }
        p { font-size: 0.95rem; color: #9ca3af; line-height: 1.6; margin-bottom: 10px; }
        ul { margin: 10px 0 0 20px; padding: 0; color: #d1d5db; font-size: 0.93rem; }
        li { margin-bottom: 6px; }
      </style>
    </head>
    <body>
      <div class="card">
        <h1>How CubeZilla Works</h1>
        <p>CubeZilla is a 3D Rubik's cube playground. It tracks every move you make and can rewind the entire scramble with CFOP‚Äëstyle commentary.</p>
        <ul>
          <li><strong>Scramble</strong>: Click ‚ÄúScramble‚Äù or spam the move buttons to create your own scramble.</li>
          <li><strong>Track</strong>: Every move you do is stored in order so the app knows your exact sequence.</li>
          <li><strong>View</strong>: Use the F / R / B / L / U / D camera buttons to look at each face.</li>
          <li><strong>Play</strong>: Click R, L, U, F etc. as many times as you like; it behaves like a real 3√ó3.</li>
          <li><strong>Solve</strong>: Press ‚ÄúSolve‚Äù to rewind your history while showing random CFOP‚Äëstyle notes.</li>
          <li><strong>Reset</strong>: ‚ÄúReset Cube‚Äù or ‚ÄúBack to menu‚Äù returns everything to a fresh solved state.</li>
        </ul>
      </div>
    </body>
    </html>
  `);
  win.document.close();
}

// 3) Back to Menu
function backToMenu() { location.reload(); }

function startSolver() {
  document.getElementById('overlay').style.display = 'none';
  document.getElementById('main-app').style.display = 'grid';
  setup3D();
}

function startNetInput() {
  document.getElementById('overlay').style.display = 'none';
  document.getElementById('main-app').style.display = 'grid';
  createNetEditor();
  document.getElementById('net-editor').style.display = 'flex';
}

function createNetEditor() {
  const faces = ['U','L','F','R','B','D'];
  netFacelets = {};
  faces.forEach(face => {
    const faceDiv = document.getElementById('face-' + face);
    faceDiv.innerHTML = '';
    netFacelets[face] = [];
    for (let i = 0; i < 9; i++) {
      const sq = document.createElement('div');
      sq.className = 'facelet';
      if (i === 4) { sq.classList.add('center'); sq.style.background = NET_COLORS[face]; }
      sq.onclick = () => { if (!sq.classList.contains('center')) sq.style.background = selectedNetColor; };
      faceDiv.appendChild(sq);
      netFacelets[face].push(sq);
    }
  });
  const paletteDiv = document.getElementById('palette');
  paletteDiv.innerHTML = '';
  NET_PALETTE.forEach((col, idx) => {
    const p = document.createElement('div');
    p.className = 'palette-color' + (idx === 0 ? ' selected' : '');
    p.style.background = col;
    p.onclick = () => {
      selectedNetColor = col;
      document.querySelectorAll('#palette .palette-color').forEach(el => el.classList.remove('selected'));
      p.classList.add('selected');
    };
    paletteDiv.appendChild(p);
  });
}

function cancelNetInput() { document.getElementById('net-editor').style.display = 'none'; }
function clearNetColors() {
  Object.keys(netFacelets).forEach(f => netFacelets[f].forEach((s, i) => { if (i !== 4) s.style.background = '#020617'; }));
}

function applyNetToCube() {
  const faces = ['U','R','F','D','L','B'];
  customFaceColors = {};
  faces.forEach(face => {
    if (netFacelets[face]) customFaceColors[face] = netFacelets[face].map((s, i) => (i === 4 ? NET_COLORS[face] : s.style.background || '#000000'));
  });
  document.getElementById('net-editor').style.display = 'none';
  setup3D();
}

function setup3D() {
  const container = document.getElementById('cube-container');
  if (renderer) container.removeChild(renderer.domElement);
  scene = new THREE.Scene();
  camera = new THREE.PerspectiveCamera(35, container.clientWidth / container.clientHeight, 0.1, 1000);
  renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
  renderer.setSize(container.clientWidth, container.clientHeight);
  container.appendChild(renderer.domElement);

  scene.add(new THREE.AmbientLight(0xffffff, 0.7));
  const dl = new THREE.DirectionalLight(0xffffff, 0.8); dl.position.set(3, 5, 4); scene.add(dl);
  cubeGroup = new THREE.Group(); scene.add(cubeGroup);
  cubies = [];

  const defaultColors = [0xff0000, 0xffa500, 0xffffff, 0xffff00, 0x00ff00, 0x0000ff];
  for (let x = -1; x <= 1; x++) {
    for (let y = -1; y <= 1; y++) {
      for (let z = -1; z <= 1; z++) {
        if (x === 0 && y === 0 && z === 0) continue;
        let materials;
        if (customFaceColors) {
          const faceOrder = ['R','L','U','D','F','B'];
          const cols = faceOrder.map(f => parseInt((customFaceColors[f][4] || NET_COLORS[f]).replace('#','0x')));
          materials = cols.map(c => new THREE.MeshLambertMaterial({ color: c }));
        } else {
          materials = defaultColors.map(c => new THREE.MeshLambertMaterial({ color: c }));
        }
        const cubie = new THREE.Mesh(new THREE.BoxGeometry(0.95, 0.95, 0.95), materials);
        cubie.position.set(x, y, z); cubies.push(cubie); cubeGroup.add(cubie);
      }
    }
  }
  snapAndReorient('front');
  animate();
}

function snapAndReorient(targetFace) {
  if (isRotating || isChangingView) return;
  const va = { front: { t: 0, p: 0.3 }, right: { t: -Math.PI/2, p: 0.3 }, back: { t: Math.PI, p: 0.3 }, left: { t: Math.PI/2, p: 0.3 }, up: { t: 0, p: -Math.PI/2 + 0.2 }, down: { t: 0, p: Math.PI/2 - 0.2 } };
  const target = va[targetFace];
  isChangingView = true;
  gsap.to(currentView, {
    theta: target.t, phi: target.p, duration: 0.6,
    onUpdate: () => {
      camera.position.set(zoomDistance * Math.cos(currentView.phi) * Math.sin(currentView.theta), zoomDistance * Math.sin(currentView.phi), zoomDistance * Math.cos(currentView.phi) * Math.cos(currentView.theta));
      camera.lookAt(0, 0, 0);
    },
    onComplete: () => { isChangingView = false; }
  });
}

// 2) screenMove (Removed Rotate Guard)
function screenMove(move) {
  let prime = move.endsWith('_prime');
  let cleanMove = move.replace('_prime', '');
  let worldDir = new THREE.Vector3();
  if (cleanMove === 'R') worldDir.set(1, 0, 0);
  else if (cleanMove === 'L') worldDir.set(-1, 0, 0);
  else if (cleanMove === 'U') worldDir.set(0, 1, 0);
  else if (cleanMove === 'D') worldDir.set(0, -1, 0);
  else if (cleanMove === 'F') worldDir.set(0, 0, 1);
  else if (cleanMove === 'B') worldDir.set(0, 0, -1);

  const inv = cubeGroup.quaternion.clone().invert();
  worldDir.applyQuaternion(inv);
  let axisName, layerSign;
  const ax = Math.abs(worldDir.x), ay = Math.abs(worldDir.y), az = Math.abs(worldDir.z);
  if (ax > ay && ax > az) { axisName = 'x'; layerSign = worldDir.x > 0 ? 1 : -1; }
  else if (ay > ax && ay > az) { axisName = 'y'; layerSign = worldDir.y > 0 ? 1 : -1; }
  else { axisName = 'z'; layerSign = worldDir.z > 0 ? 1 : -1; }

  moveHistory.push(move);
  handleMove(axisName, layerSign, prime);
}

function handleMove(axis, layerSign, prime) {
  if (isRotating) return; // Keep this guard to prevent overlapping animations
  isRotating = true;
  const pivot = new THREE.Group(); cubeGroup.add(pivot);
  const moving = [];
  cubies.forEach(c => { if (Math.abs(c.position[axis] - layerSign) < 0.1) { pivot.attach(c); moving.push(c); } });
  const angle = (prime ? 1 : -1) * Math.PI / 2;
  gsap.to(pivot.rotation, { [axis]: angle, duration: 0.25, onComplete: () => {
    moving.forEach(c => { cubeGroup.attach(c); c.position.set(Math.round(c.position.x), Math.round(c.position.y), Math.round(c.position.z)); });
    scene.remove(pivot); isRotating = false;
  }});
}

function scramble() {
  let count = 0;
  const moves = ['R','R_prime','L','L_prime','U','U_prime','F','F_prime'];
  const interval = setInterval(() => {
    if (isRotating || isChangingView) return;
    if (count >= 15) { clearInterval(interval); return; }
    screenMove(moves[Math.floor(Math.random() * moves.length)]);
    count++;
  }, 260);
}

function solveCube() {
  if (moveHistory.length === 0) return;
  const reverseMoves = moveHistory.slice().reverse().map(m => m.endsWith('_prime') ? m.replace('_prime','') : m + '_prime');
  setSolveInfo(pickRandom(solveMessages.scan));
  setTimeout(() => {
    setSolveInfo(pickRandom(solveMessages.eval));
    setTimeout(() => {
      setSolveInfo(pickRandom(solveMessages.method));
      setTimeout(() => {
        let idx = 0;
        setSolveInfo(pickRandom(solveMessages.execute));
        const interval = setInterval(() => {
          if (isRotating || isChangingView) return;
          if (idx >= reverseMoves.length) { clearInterval(interval); moveHistory = []; setSolveInfo('Solved!'); setTimeout(() => setSolveInfo(''), 1800); return; }
          screenMove(reverseMoves[idx++]);
        }, 320);
      }, 900);
    }, 1100);
  }, 1100);
}

function resetCube() { location.reload(); }
function resetView() { snapAndReorient('front'); }
function animate() { requestAnimationFrame(animate); if(renderer) renderer.render(scene, camera); }
</script>
</body>
</html>
