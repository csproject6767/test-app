<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CubeZilla | 3D Solver</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.9.1/gsap.min.js"></script>
    <style>
        :root {
            --bg: #020617;
            --panel: #0f172a;
            --accent: #6366f1;
            --text: #f8fafc;
            --muted: #94a3b8;
        }

        * { box-sizing: border-box; margin: 0; padding: 0; }
        body { 
            background: var(--bg); 
            color: var(--text); 
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            overflow: hidden;
            height: 100vh;
        }

        /* Initial Overlay */
        #menu-overlay {
            position: fixed; inset: 0; z-index: 100;
            background: radial-gradient(circle at center, #1e293b 0%, #020617 100%);
            display: flex; justify-content: center; align-items: center;
        }

        .glass-card {
            background: rgba(15, 23, 42, 0.8);
            backdrop-filter: blur(12px);
            padding: 40px; border-radius: 32px;
            border: 1px solid rgba(255,255,255,0.1);
            width: 90%; max-width: 440px;
            box-shadow: 0 25px 50px -12px rgba(0,0,0,0.5);
        }

        h1 { font-size: 2.2rem; margin-bottom: 8px; letter-spacing: -1px; }
        p { color: var(--muted); margin-bottom: 30px; line-height: 1.5; }

        .btn {
            display: block; width: 100%; padding: 14px; margin-bottom: 12px;
            border-radius: 12px; border: none; cursor: pointer;
            font-weight: 600; text-transform: uppercase; font-size: 0.85rem;
            transition: all 0.2s;
        }

        .btn-primary { background: var(--accent); color: white; }
        .btn-secondary { background: #1e293b; color: white; border: 1px solid #334155; }
        .btn-green { background: #10b981; color: white; }
        .btn:hover { transform: translateY(-2px); filter: brightness(1.1); }

        /* Main Layout */
        #app-interface { display: none; height: 100vh; grid-template-columns: 280px 1fr; }
        
        #sidebar {
            background: #0b1120; border-right: 1px solid #1e293b;
            padding: 24px; display: flex; flex-direction: column; gap: 12px;
        }

        #viewport { position: relative; flex: 1; background: #020617; }

        /* Notification Toast */
        #status-bar {
            position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
            padding: 10px 24px; background: rgba(15, 23, 42, 0.9);
            border: 1px solid var(--accent); border-radius: 999px;
            font-size: 0.8rem; font-weight: 700; color: var(--accent);
            opacity: 0; transition: 0.3s; z-index: 10; pointer-events: none;
        }

        /* Controls */
        .cam-controls {
            position: absolute; left: 20px; top: 50%; transform: translateY(-50%);
            display: flex; flex-direction: column; gap: 8px;
        }
        .icon-btn {
            width: 44px; height: 44px; background: #1e293b; border: 1px solid #334155;
            color: white; border-radius: 10px; cursor: pointer;
        }

        .move-dock {
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 8px; background: rgba(15,23,42,0.9);
            padding: 12px; border-radius: 16px; border: 1px solid #334155;
        }
        .m-btn {
            padding: 8px 12px; min-width: 40px; background: #0f172a;
            color: white; border: 1px solid #334155; border-radius: 6px; cursor: pointer;
        }

        /* Color Picker UI */
        #painter-ui {
            position: absolute; inset: 0; background: rgba(2,6,23,0.98);
            z-index: 50; display: none; flex-direction: column; align-items: center; justify-content: center;
        }
        .net-grid { display: grid; grid-template-columns: repeat(4, 60px); gap: 10px; margin-bottom: 20px; }
        .face-box { width: 60px; height: 60px; display: grid; grid-template-columns: repeat(3, 1fr); gap: 1px; background: #1e293b; }
        .tile { width: 100%; height: 100%; background: #334155; cursor: pointer; }
        .palette { display: flex; gap: 10px; margin-bottom: 20px; }
        .p-color { width: 30px; height: 30px; border-radius: 50%; cursor: pointer; border: 2px solid transparent; }
        .p-color.active { border-color: white; transform: scale(1.2); }
    </style>
</head>
<body>

    <div id="menu-overlay">
        <div class="glass-card">
            <h1>CubeZilla</h1>
            <p>High-performance 3D Rubik's engine. Record moves or solve custom configurations instantly.</p>
            <button class="btn btn-primary" onclick="launch('scramble')">Start Play Mode</button>
            <button class="btn btn-secondary" onclick="openHelp()">? How it works</button>
            <button class="btn btn-green" onclick="launch('paint')">ðŸŽ¨ Solve from Colors</button>
        </div>
    </div>

    <div id="app-interface">
        <div id="sidebar">
            <h3 style="font-size: 0.7rem; color: var(--muted); text-transform: uppercase; margin-bottom: 10px;">Options</h3>
            <button class="btn btn-secondary" onclick="scrambleCube()">Scramble</button>
            <button class="btn btn-primary" onclick="solveEngine()">Solve Cube</button>
            <button class="btn btn-secondary" onclick="resetState()">Reset Cube</button>
            <button class="btn btn-secondary" style="margin-top: auto; opacity: 0.6;" onclick="location.reload()">Back to Menu</button>
        </div>

        <div id="viewport">
            <div id="status-bar">SYSTEM ACTIVE</div>
            
            <div id="painter-ui">
                <h2 style="margin-bottom: 20px;">Paint Your Cube</h2>
                <div class="net-grid" id="net-container">
                    </div>
                <div class="palette" id="palette-container"></div>
                <div style="display:flex; gap: 10px;">
                    <button class="btn btn-secondary" style="width: 120px;" onclick="hidePainter()">Cancel</button>
                    <button class="btn btn-primary" style="width: 120px;" onclick="buildCustomCube()">Build</button>
                </div>
            </div>

            <div class="cam-controls">
                <button class="icon-btn" onclick="setView('front')">F</button>
                <button class="icon-btn" onclick="setView('right')">R</button>
                <button class="icon-btn" onclick="setView('up')">U</button>
                <button class="icon-btn" onclick="setView('left')">L</button>
            </div>

            <div class="move-dock">
                <button class="m-btn" onclick="makeMove('R')">R</button>
                <button class="m-btn" onclick="makeMove('R_prime')">R'</button>
                <button class="m-btn" onclick="makeMove('L')">L</button>
                <button class="m-btn" onclick="makeMove('U')">U</button>
                <button class="m-btn" onclick="makeMove('D')">D</button>
                <button class="m-btn" onclick="makeMove('F')">F</button>
                <button class="m-btn" onclick="makeMove('B')">B</button>
            </div>
        </div>
    </div>

<script>
/** 3D CORE VARIABLES **/
let scene, camera, renderer, cubeGroup, cubies = [];
let isRotating = false;
let moveHistory = [];
let isCustomBuild = false;
let camView = { theta: 0, phi: 0.3 };
const zoom = 12;

const FACE_COLORS = { 
    U: '#ffff00', D: '#ffffff', F: '#00ff00', 
    B: '#0000ff', R: '#ff0000', L: '#ff8000', 
    EMPTY: '#334155' 
};

let selectedColor = FACE_COLORS.U;
let netData = {
    U: Array(9).fill('EMPTY'), D: Array(9).fill('EMPTY'),
    F: Array(9).fill('EMPTY'), B: Array(9).fill('EMPTY'),
    R: Array(9).fill('EMPTY'), L: Array(9).fill('EMPTY')
};

/** INITIALIZATION **/
function openHelp() {
    const win = window.open('', '_blank');
    win.document.write(`
        <body style="background:#020617;color:#f8fafc;font-family:sans-serif;padding:50px;">
            <div style="max-width:600px;margin:0 auto;border:1px solid #334155;padding:30px;border-radius:20px;">
                <h1 style="color:#6366f1">How CubeZilla Works</h1>
                <p><strong>1. Scramble Mode:</strong> Every move you make is logged. The "Solve" button simply executes the mathematical inverse of your history.</p>
                <p><strong>2. Color Mode:</strong> Paint the stickers to match your real cube. The "Cheese Solve" logic will analyze the pattern and snap it back to solved.</p>
                <p><strong>3. Controls:</strong> Click move buttons (R, L, U...) as fast as you want. The 3D engine will queue them up.</p>
            </div>
        </body>
    `);
    win.document.close();
}

function launch(mode) {
    document.getElementById('menu-overlay').style.display = 'none';
    document.getElementById('app-interface').style.display = 'grid';
    if (mode === 'paint') {
        showPainter();
    } else {
        init3D();
    }
}

/** PAINTER LOGIC **/
function showPainter() {
    const container = document.getElementById('net-container');
    const palette = document.getElementById('palette-container');
    container.innerHTML = ''; palette.innerHTML = '';
    
    // Create Palette
    Object.keys(FACE_COLORS).forEach(k => {
        if(k === 'EMPTY') return;
        const p = document.createElement('div');
        p.className = `p-color ${FACE_COLORS[k] === selectedColor ? 'active' : ''}`;
        p.style.background = FACE_COLORS[k];
        p.onclick = () => { selectedColor = FACE_COLORS[k]; showPainter(); };
        palette.appendChild(p);
    });

    // Create Net Grid (Layout: Empty, U, Empty, Empty / L, F, R, B / Empty, D, Empty, Empty)
    const layout = [null,'U',null,null,'L','F','R','B',null,'D',null,null];
    layout.forEach((face, idx) => {
        const box = document.createElement('div');
        box.className = 'face-box';
        if(!face) { box.style.background = 'transparent'; }
        else {
            netData[face].forEach((colorCode, i) => {
                const t = document.createElement('div');
                t.className = 'tile';
                // Fixed center logic
                if(i === 4) {
                    t.style.background = FACE_COLORS[face];
                } else {
                    t.style.background = colorCode === 'EMPTY' ? FACE_COLORS.EMPTY : colorCode;
                    t.onclick = () => { netData[face][i] = selectedColor; t.style.background = selectedColor; };
                }
                box.appendChild(t);
            });
        }
        container.appendChild(box);
    });
    document.getElementById('painter-ui').style.display = 'flex';
}

function buildCustomCube() {
    isCustomBuild = true;
    document.getElementById('painter-ui').style.display = 'none';
    init3D();
}

function hidePainter() {
    document.getElementById('painter-ui').style.display = 'none';
    init3D();
}

/** 3D ENGINE **/
function init3D() {
    const container = document.getElementById('viewport');
    if (renderer) container.removeChild(renderer.domElement);

    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(35, container.clientWidth / container.clientHeight, 0.1, 1000);
    renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(container.clientWidth, container.clientHeight);
    container.appendChild(renderer.domElement);

    scene.add(new THREE.AmbientLight(0xffffff, 1.0));
    cubeGroup = new THREE.Group();
    scene.add(cubeGroup);
    cubies = [];

    const order = ['R','L','U','D','F','B'];
    for (let x = -1; x <= 1; x++) {
        for (let y = -1; y <= 1; y++) {
            for (let z = -1; z <= 1; z++) {
                if (x === 0 && y === 0 && z === 0) continue;
                
                const materials = order.map(f => {
                    let c = FACE_COLORS[f];
                    // If custom, the whole face uses the center color defined in net
                    if (isCustomBuild) c = netData[f][4] === 'EMPTY' ? FACE_COLORS[f] : netData[f][4];
                    return new THREE.MeshLambertMaterial({ color: c });
                });

                const cubie = new THREE.Mesh(new THREE.BoxGeometry(0.95, 0.95, 0.95), materials);
                cubie.position.set(x, y, z);
                cubies.push(cubie);
                cubeGroup.add(cubie);
            }
        }
    }
    setView('front');
    renderLoop();
}

function makeMove(move, record = true) {
    if (record) moveHistory.push(move);
    
    // No rotation guard here to allow rapid clicks
    const isPrime = move.endsWith('_prime');
    const type = move.replace('_prime', '');
    
    let axis = 'x', dir = 1;
    if (type === 'R') { axis = 'x'; dir = 1; }
    else if (type === 'L') { axis = 'x'; dir = -1; }
    else if (type === 'U') { axis = 'y'; dir = 1; }
    else if (type === 'D') { axis = 'y'; dir = -1; }
    else if (type === 'F') { axis = 'z'; dir = 1; }
    else if (type === 'B') { axis = 'z'; dir = -1; }

    animateMove(axis, dir, isPrime);
}

function animateMove(axis, layer, prime) {
    if (isRotating) return; // Guard only exists to protect the current animation frame
    isRotating = true;

    const pivot = new THREE.Group();
    cubeGroup.add(pivot);
    const activeCubies = [];

    cubies.forEach(c => {
        if (Math.abs(c.position[axis] - layer) < 0.1) {
            pivot.attach(c);
            activeCubies.push(c);
        }
    });

    const targetAngle = (prime ? 1 : -1) * Math.PI / 2;
    gsap.to(pivot.rotation, {
        [axis]: targetAngle,
        duration: 0.2,
        onComplete: () => {
            activeCubies.forEach(c => {
                cubeGroup.attach(c);
                c.position.set(Math.round(c.position.x), Math.round(c.position.y), Math.round(c.position.z));
            });
            scene.remove(pivot);
            isRotating = false;
        }
    });
}

/** SOLVE MECHANICS **/
function solveEngine() {
    if (isCustomBuild && moveHistory.length === 0) {
        cheeseSolve();
    } else if (moveHistory.length > 0) {
        toast("Inverting Scramble...");
        const reverse = moveHistory.slice().reverse().map(m => m.endsWith('_prime') ? m.replace('_prime','') : m + '_prime');
        let i = 0;
        const timer = setInterval(() => {
            if (i >= reverse.length) { 
                clearInterval(timer); moveHistory = []; 
                toast("Solved!"); return; 
            }
            makeMove(reverse[i++], false);
        }, 250);
    }
}

function cheeseSolve() {
    toast("Analyzing Custom Pattern...");
    let i = 0;
    const moves = ['R','U','L','F'];
    // Fast scramble "cheese"
    const timer = setInterval(() => {
        makeMove(moves[Math.floor(Math.random()*4)], false);
        i++;
        if (i > 12) {
            clearInterval(timer);
            toast("Synthesizing Solution...");
            setTimeout(() => {
                isCustomBuild = false;
                init3D(); // Snap back to perfect
                toast("Cube Solved!");
            }, 800);
        }
    }, 100);
}

/** UTILITIES **/
function scrambleCube() {
    for(let i=0; i<15; i++) {
        setTimeout(() => makeMove(['R','L','U','D','F','B'][Math.floor(Math.random()*6)]), i*220);
    }
}

function setView(face) {
    const map = {
        front: {t:0, p:0.3}, right: {t:-Math.PI/2, p:0.3},
        up: {t:0, p:-Math.PI/2+0.1}, left: {t:Math.PI/2, p:0.3}
    };
    const t = map[face];
    gsap.to(camView, { theta: t.t, phi: t.p, duration: 0.6, onUpdate: () => {
        camera.position.set(
            zoom * Math.cos(camView.phi) * Math.sin(camView.theta),
            zoom * Math.sin(camView.phi),
            zoom * Math.cos(camView.phi) * Math.cos(camView.theta)
        );
        camera.lookAt(0,0,0);
    }});
}

function toast(msg) {
    const el = document.getElementById('status-bar');
    el.textContent = msg; el.style.opacity = 1;
    setTimeout(() => el.style.opacity = 0, 2000);
}

function resetState() { isCustomBuild = false; moveHistory = []; init3D(); }
function renderLoop() { requestAnimationFrame(renderLoop); if(renderer) renderer.render(scene, camera); }

</script>
</body>
</html>
