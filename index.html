<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Green-Black Cube Pro</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body { margin: 0; background-color: #000; color: #0f0; font-family: 'Segoe UI', monospace; overflow: hidden; }
        
        /* UI Screens */
        #ui-layer { position: absolute; width: 100%; height: 100%; display: flex; justify-content: center; align-items: center; z-index: 100; background: black; }
        .page { display: none; text-align: center; }
        .active { display: flex; flex-direction: column; gap: 20px; }

        /* Popping Buttons */
        button {
            padding: 15px 40px; background: #000; color: #0f0; border: 3px solid #0f0;
            font-weight: bold; cursor: pointer; transition: all 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            font-size: 1.2rem; text-transform: uppercase; letter-spacing: 2px;
        }
        button:hover { transform: scale(1.15); background: #0f0; color: #000; box-shadow: 0 0 20px #0f0; }

        /* Interactive Layout (Split Screen) */
        #main-app { display: none; width: 100vw; height: 100vh; grid-template-columns: 1fr 1fr; }
        #text-sidebar { padding: 40px; border-right: 2px solid #0f0; background: rgba(0,20,0,1); display: flex; flex-direction: column; justify-content: center; }
        #canvas-container { position: relative; background: #050505; }
        
        h1 { text-shadow: 0 0 10px #0f0; margin-bottom: 30px; }
        p { line-height: 1.6; font-size: 1.1rem; color: #8f8; }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div id="page1" class="page active">
            <h1>CUBE KNOWLEDGE SURVEY</h1>
            <button onclick="nextPage('page2')">I'm a Beginner</button>
            <button onclick="nextPage('page2')">I know a few moves</button>
        </div>
        <div id="page2" class="page">
            <h1>CHOOSE YOUR PATH</h1>
            <button onclick="launchApp('Learn')">LEARN TO SOLVE</button>
            <button onclick="launchApp('Solver')">AUTO SOLVER MODE</button>
        </div>
    </div>

    <div id="main-app">
        <div id="text-sidebar">
            <h1 id="mode-title">LEARNING MODE</h1>
            <p id="mode-desc">Welcome to the interactive trainer. Use your mouse to rotate the cube in 3D space. 
            <br><br>
            <b>Instructions:</b><br>
            • Click and drag anywhere on the right to rotate the entire cube.<br>
            • Observe the green boundaries to understand the cube's orientation.</p>
            <button onclick="location.reload()" style="margin-top:50px; font-size: 0.8rem; width: fit-content;">Reset App</button>
        </div>
        <div id="canvas-container"></div>
    </div>

    <script>
        function nextPage(id) {
            document.querySelectorAll('.page').forEach(p => p.classList.remove('active'));
            document.getElementById(id).classList.add('active');
        }

        function launchApp(mode) {
            document.getElementById('ui-layer').style.display = 'none';
            document.getElementById('main-app').style.display = 'grid';
            document.getElementById('mode-title').innerText = mode + " MODE";
            init3D();
        }

        function init3D() {
            const container = document.getElementById('canvas-container');
            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.1, 1000);
            const renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            container.appendChild(renderer.domElement);

            // Lighting (Brighter)
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
            scene.add(ambientLight);
            const pointLight = new THREE.PointLight(0x00ff00, 1);
            pointLight.position.set(5, 5, 5);
            scene.add(pointLight);

            // Create Rubik's Cube with clear boundaries
            const cubeGroup = new THREE.Group();
            const cubeSize = 3;
            const gap = 0.05;

            for (let x = 0; x < cubeSize; x++) {
                for (let y = 0; y < cubeSize; y++) {
                    for (let z = 0; z < cubeSize; z++) {
                        // Create the cubie (Black box)
                        const geometry = new THREE.BoxGeometry(1, 1, 1);
                        const material = new THREE.MeshLambertMaterial({ color: 0x000000 });
                        const cubie = new THREE.Mesh(geometry, material);

                        // Create the bright green boundary (edges)
                        const edges = new THREE.EdgesGeometry(geometry);
                        const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x00ff00, linewidth: 2 }));
                        
                        cubie.add(line);
                        cubie.position.set(x - 1, y - 1, z - 1);
                        cubeGroup.add(cubie);
                    }
                }
            }
            scene.add(cubeGroup);
            camera.position.set(5, 5, 5);
            camera.lookAt(0, 0, 0);

            // Movement Logic
            let isDragging = false;
            let previousMousePosition = { x: 0, y: 0 };

            container.addEventListener('mousedown', () => isDragging = true);
            window.addEventListener('mouseup', () => isDragging = false);
            window.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    const deltaX = e.movementX;
                    const deltaY = e.movementY;
                    cubeGroup.rotation.y += deltaX * 0.01;
                    cubeGroup.rotation.x += deltaY * 0.01;
                }
            });

            function animate() {
                requestAnimationFrame(animate);
                renderer.render(scene, camera);
            }
            animate();

            window.addEventListener('resize', () => {
                camera.aspect = container.clientWidth / container.clientHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(container.clientWidth, container.clientHeight);
            });
        }
    </script>
</body>
</html>
