
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Cubezilla</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r152/three.min.js"></script>
<style>
:root { --neon:#00ff00; }
html,body{
  margin:0;width:100%;height:100%;
  background:#000;color:var(--neon);
  font-family:'Courier New',monospace;
  overflow:hidden;
}
#overlay{
  position:fixed;inset:0;z-index:9999;
  background:#000;
  display:flex;justify-content:center;align-items:center;
}
.page{
  display:none;text-align:center;
  border:2px solid var(--neon);
  padding:40px;background:#001100;
  max-width:520px;
}
.page.active{display:block}
.pop-btn{
  background:black;border:2px solid var(--neon);
  color:var(--neon);padding:12px 25px;
  cursor:pointer;margin:10px;font-weight:bold;
}
.pop-btn:hover{background:var(--neon);color:black}

#main-app{
  display:none;
  width:100vw;height:100vh;
  grid-template-columns:320px 1fr;
}
#sidebar{
  background:rgba(0,10,0,.95);
  border-right:1px solid var(--neon);
  padding:25px;
  display:flex;flex-direction:column;
}
#cube-container{
  width:100%;height:100%;
}
.lesson-box{
  background:#002200;
  border:1px solid var(--neon);
  padding:15px;margin-top:20px;
  font-size:.85rem;
}
.warning-red{
  color:#ff3333;font-weight:bold;
  border:1px solid #ff3333;
  padding:5px;margin:10px 0;
}
</style>
</head>
<body>

<div id="overlay">
  <div id="p1" class="page active">
    <h1>WELCOME TO CUBEZILLA</h1>
    <p>Interactive Rubik’s Cube Training System</p>
    <button class="pop-btn" onclick="goPage('p-warn')">START</button>
  </div>

  <div id="p-warn" class="page">
    <h1 style="color:#ff3333">⚠ WARNING ⚠</h1>
    <div class="warning-red">THIS TAKES PRACTICE</div>
    <p>No instant solving. Muscle memory required.</p>
    <button class="pop-btn" onclick="goPage('p-method')">CONTINUE</button>
  </div>

  <div id="p-method" class="page">
    <h1>SELECT METHOD</h1>
    <p><b>CFOP</b> – Advanced</p>
    <button class="pop-btn" onclick="initApp('CFOP')">CFOP</button>
    <hr style="border-color:var(--neon)">
    <p><b>BEGINNER</b> – Layer by layer</p>
    <button class="pop-btn" onclick="initApp('Beginner')">BEGINNER</button>
  </div>
</div>

<div id="main-app">
  <div id="sidebar">
    <h2 id="method-title">SYSTEM</h2>
    <div class="lesson-box">
      <h3>Lesson 1</h3>
      <p>Drag background → rotate view</p>
      <p>Drag a face → rotate layer</p>
    </div>
    <button class="pop-btn" style="margin-top:auto" onclick="scramble()">SCRAMBLE</button>
  </div>
  <div id="cube-container"></div>
</div>

<script>
function goPage(id){
  document.querySelectorAll('.page').forEach(p=>p.classList.remove('active'));
  document.getElementById(id).classList.add('active');
}
function initApp(method){
  document.getElementById('overlay').style.display='none';
  document.getElementById('main-app').style.display='grid';
  document.getElementById('method-title').innerText=method+' HUB';
  initCube();
}

/* ===== CUBE (FIXED AXES + VISIBILITY) ===== */
let scene,camera,renderer,cubeGroup;
let cubies=[],raycaster=new THREE.Raycaster(),mouse=new THREE.Vector2();
let dragStart=null,picked=null,normal=null,rotating=false;
let camRot={x:0,y:0};

function initCube(){
  const c=document.getElementById('cube-container');
  scene=new THREE.Scene();

  camera=new THREE.PerspectiveCamera(45,c.clientWidth/c.clientHeight,.1,100);
  camera.position.set(6,6,6);
  camera.lookAt(0,0,0);

  renderer=new THREE.WebGLRenderer({antialias:true,alpha:true});
  renderer.setSize(c.clientWidth,c.clientHeight);
  c.appendChild(renderer.domElement);

  scene.add(new THREE.AmbientLight(0xffffff,.9));
  const d=new THREE.DirectionalLight(0xffffff,.6);
  d.position.set(5,10,7);
  scene.add(d);

  cubeGroup=new THREE.Group();
  scene.add(cubeGroup);

  buildCube();

  c.addEventListener('pointerdown',onDown);
  c.addEventListener('pointerup',onUp);

  animate();
}

function buildCube(){
  cubies=[];cubeGroup.clear();
  const C=[0xff0000,0xff8000,0xffffff,0xffff00,0x00ff00,0x0000ff];
  for(let x=-1;x<=1;x++)for(let y=-1;y<=1;y++)for(let z=-1;z<=1;z++){
    const m=[
      new THREE.MeshLambertMaterial({color:x==1?C[0]:0x111111}),
      new THREE.MeshLambertMaterial({color:x==-1?C[1]:0x111111}),
      new THREE.MeshLambertMaterial({color:y==1?C[2]:0x111111}),
      new THREE.MeshLambertMaterial({color:y==-1?C[3]:0x111111}),
      new THREE.MeshLambertMaterial({color:z==1?C[4]:0x111111}),
      new THREE.MeshLambertMaterial({color:z==-1?C[5]:0x111111}),
    ];
    const cube=new THREE.Mesh(new THREE.BoxGeometry(.95,.95,.95),m);
    cube.position.set(x,y,z);
    cubies.push(cube);
    cubeGroup.add(cube);
  }
}

function onDown(e){
  dragStart={x:e.clientX,y:e.clientY};
  mouse.x=(e.offsetX/renderer.domElement.width)*2-1;
  mouse.y=-(e.offsetY/renderer.domElement.height)*2+1;
  raycaster.setFromCamera(mouse,camera);
  const hit=raycaster.intersectObjects(cubies)[0];
  if(hit){picked=hit.object;normal=hit.face.normal.clone();}
  else picked=null;
}

function onUp(e){
  if(!dragStart)return;
  const dx=e.clientX-dragStart.x;
  const dy=e.clientY-dragStart.y;
  if(!picked){
    camRot.y+=dx*.005;
    camRot.x+=dy*.005;
    cubeGroup.rotation.set(camRot.x,camRot.y,0);
  }else if(!rotating){
    rotateFace(picked,normal,dx,dy);
  }
  dragStart=null;picked=null;
}

function rotateFace(c,n,dx,dy){
  rotating=true;
  let axis,layer;
  const dir=(Math.abs(dx)>Math.abs(dy)?dx:dy)>0?1:-1;

  if(Math.abs(n.x)==1){axis='x';layer=c.position.x;}
  else if(Math.abs(n.y)==1){axis='y';layer=c.position.y;}
  else{axis='z';layer=c.position.z;}

  const pivot=new THREE.Group();
  scene.add(pivot);
  const moving=cubies.filter(o=>Math.abs(o.position[axis]-layer)<.1);
  moving.forEach(o=>pivot.attach(o));

  const start=performance.now();
  (function anim(){
    const t=Math.min((performance.now()-start)/200,1);
    pivot.rotation[axis]=dir*Math.PI/2*t;
    if(t<1)requestAnimationFrame(anim);
    else{
      moving.forEach(o=>{
        cubeGroup.attach(o);
        o.position.set(
          Math.round(o.position.x),
          Math.round(o.position.y),
          Math.round(o.position.z)
        );
        o.rotation.set(
          Math.round(o.rotation.x/(Math.PI/2))*(Math.PI/2),
          Math.round(o.rotation.y/(Math.PI/2))*(Math.PI/2),
          Math.round(o.rotation.z/(Math.PI/2))*(Math.PI/2)
        );
      });
      scene.remove(pivot);
      rotating=false;
    }
  })();
}

function scramble(){
  if(rotating)return;
  let i=0;
  const axes=['x','y','z'];
  const s=setInterval(()=>{
    const a=axes[Math.floor(Math.random()*3)];
    const l=[-1,0,1][Math.floor(Math.random()*3)];
    const c=cubies.find(o=>o.position[a]==l);
    rotateFace(c,{x:a=='x',y:a=='y',z:a=='z'},1,0);
    if(++i>12)clearInterval(s);
  },250);
}

function animate(){
  requestAnimationFrame(animate);
  renderer.render(scene,camera);
}
</script>
</body>
</html>
